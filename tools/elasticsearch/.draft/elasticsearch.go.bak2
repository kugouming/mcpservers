package main

import (
	"encoding/json"
	"fmt"
	"os"
	"os/signal"
	"strings"
	"syscall"

	"github.com/elastic/go-elasticsearch/v7"
	"github.com/elastic/go-elasticsearch/v7/esapi"
	"github.com/modelcontextprotocol/sdk-go/server/mcp"
	"github.com/modelcontextprotocol/sdk-go/server/stdio"
)

// Config 定义 Elasticsearch 配置
type Config struct {
	URL      string `json:"url"`
	APIKey   string `json:"apiKey,omitempty"`
	Username string `json:"username,omitempty"`
	Password string `json:"password,omitempty"`
	CACert   string `json:"caCert,omitempty"`
}

// Validate 验证配置
func (c *Config) Validate() error {
	if c.URL == "" {
		return fmt.Errorf("Elasticsearch URL cannot be empty")
	}

	// 验证认证方式
	if c.Username != "" && c.Password == "" {
		return fmt.Errorf("password must be provided when username is set")
	}
	if c.Password != "" && c.Username == "" {
		return fmt.Errorf("username must be provided when password is set")
	}

	return nil
}

// createElasticsearchMcpServer 创建 Elasticsearch MCP 服务器
func createElasticsearchMcpServer(config *Config) (*mcp.Server, error) {
	if err := config.Validate(); err != nil {
		return nil, err
	}

	// 配置 ES 客户端
	cfg := elasticsearch.Config{
		Addresses: []string{config.URL},
	}

	if config.APIKey != "" {
		cfg.APIKey = config.APIKey
	} else if config.Username != "" && config.Password != "" {
		cfg.Username = config.Username
		cfg.Password = config.Password
	}

	if config.CACert != "" {
		caCert, err := os.ReadFile(config.CACert)
		if err != nil {
			return nil, fmt.Errorf("failed to read certificate file: %v", err)
		}
		cfg.CACert = caCert
	}

	es, err := elasticsearch.NewClient(cfg)
	if err != nil {
		return nil, fmt.Errorf("error creating elasticsearch client: %v", err)
	}

	server := mcp.NewServer("elasticsearch-mcp-server", "0.1.1")

	// Tool 1: List indices
	server.AddTool("list_indices", "List all available Elasticsearch indices",
		func(params map[string]interface{}) ([]mcp.Content, error) {
			indexPattern, ok := params["indexPattern"].(string)
			if !ok || indexPattern == "" {
				return nil, fmt.Errorf("index pattern is required")
			}

			res, err := es.Cat.Indices(
				es.Cat.Indices.WithIndex(indexPattern),
				es.Cat.Indices.WithFormat("json"),
			)
			if err != nil {
				return nil, fmt.Errorf("failed to list indices: %v", err)
			}
			defer res.Body.Close()

			var indices []map[string]interface{}
			if err := json.NewDecoder(res.Body).Decode(&indices); err != nil {
				return nil, fmt.Errorf("failed to decode response: %v", err)
			}

			indicesInfo := make([]map[string]interface{}, len(indices))
			for i, idx := range indices {
				indicesInfo[i] = map[string]interface{}{
					"index":     idx["index"],
					"health":    idx["health"],
					"status":    idx["status"],
					"docsCount": idx["docs.count"],
				}
			}

			content, err := json.MarshalIndent(indicesInfo, "", "  ")
			if err != nil {
				return nil, fmt.Errorf("failed to marshal indices info: %v", err)
			}

			return []mcp.Content{
				{Type: "text", Text: fmt.Sprintf("Found %d indices", len(indicesInfo))},
				{Type: "text", Text: string(content)},
			}, nil
		})

	// Tool 2: Get mappings
	server.AddTool("get_mappings", "Get field mappings for a specific Elasticsearch index",
		func(params map[string]interface{}) ([]mcp.Content, error) {
			index, ok := params["index"].(string)
			if !ok || index == "" {
				return nil, fmt.Errorf("index name is required")
			}

			res, err := es.Indices.GetMapping(
				es.Indices.GetMapping.WithIndex(index),
			)
			if err != nil {
				return nil, fmt.Errorf("failed to get mappings: %v", err)
			}
			defer res.Body.Close()

			var response map[string]interface{}
			if err := json.NewDecoder(res.Body).Decode(&response); err != nil {
				return nil, fmt.Errorf("failed to decode response: %v", err)
			}

			content, err := json.MarshalIndent(response[index].(map[string]interface{})["mappings"], "", "  ")
			if err != nil {
				return nil, fmt.Errorf("failed to marshal mappings: %v", err)
			}

			return []mcp.Content{
				{Type: "text", Text: fmt.Sprintf("Mappings for index: %s", index)},
				{Type: "text", Text: string(content)},
			}, nil
		})

	// Tool 3: Search
	server.AddTool("search", "Perform an Elasticsearch search with the provided query DSL",
		func(params map[string]interface{}) ([]mcp.Content, error) {
			index, ok := params["index"].(string)
			if !ok || index == "" {
				return nil, fmt.Errorf("index name is required")
			}

			queryBody, ok := params["queryBody"].(map[string]interface{})
			if !ok {
				return nil, fmt.Errorf("queryBody must be a valid Elasticsearch query DSL object")
			}

			// 获取映射以识别文本字段
			mappingRes, err := es.Indices.GetMapping(
				es.Indices.GetMapping.WithIndex(index),
			)
			if err != nil {
				return nil, fmt.Errorf("failed to get mappings: %v", err)
			}
			defer mappingRes.Body.Close()

			var mappingResponse map[string]interface{}
			if err := json.NewDecoder(mappingRes.Body).Decode(&mappingResponse); err != nil {
				return nil, fmt.Errorf("failed to decode mapping response: %v", err)
			}

			// 构建搜索请求
			queryBody["highlight"] = map[string]interface{}{
				"fields":    map[string]interface{}{},
				"pre_tags":  []string{"<em>"},
				"post_tags": []string{"</em>"},
			}

			// 添加文本字段到高亮
			if mappings, ok := mappingResponse[index].(map[string]interface{}); ok {
				if props, ok := mappings["mappings"].(map[string]interface{})["properties"].(map[string]interface{}); ok {
					for field, fieldData := range props {
						if fieldMap, ok := fieldData.(map[string]interface{}); ok {
							if fieldType, ok := fieldMap["type"].(string); ok && fieldType == "text" {
								queryBody["highlight"].(map[string]interface{})["fields"].(map[string]interface{})[field] = map[string]interface{}{}
							}
						}
					}
				}
			}

			// 执行搜索
			queryJSON, err := json.Marshal(queryBody)
			if err != nil {
				return nil, fmt.Errorf("failed to marshal query: %v", err)
			}

			res, err := es.Search(
				es.Search.WithIndex(index),
				es.Search.WithBody(strings.NewReader(string(queryJSON))),
			)
			if err != nil {
				return nil, fmt.Errorf("search failed: %v", err)
			}
			defer res.Body.Close()

			var searchResponse map[string]interface{}
			if err := json.NewDecoder(res.Body).Decode(&searchResponse); err != nil {
				return nil, fmt.Errorf("failed to decode search response: %v", err)
			}

			hits := searchResponse["hits"].(map[string]interface{})
			total := hits["total"].(map[string]interface{})["value"].(float64)
			hitsArray := hits["hits"].([]interface{})

			from := 0
			if fromVal, ok := queryBody["from"].(float64); ok {
				from = int(fromVal)
			}

			contents := []mcp.Content{
				{Type: "text", Text: fmt.Sprintf("Total results: %.0f, showing %d from position %d", total, len(hitsArray), from)},
			}

			for _, hit := range hitsArray {
				hitMap := hit.(map[string]interface{})
				source := hitMap["_source"].(map[string]interface{})
				highlight := hitMap["highlight"].(map[string]interface{})

				var content strings.Builder
				for field, highlights := range highlight {
					if highlightsArray, ok := highlights.([]interface{}); ok && len(highlightsArray) > 0 {
						content.WriteString(fmt.Sprintf("%s (highlighted): %s\n", field, strings.Join(interfaceSliceToStringSlice(highlightsArray), " ... ")))
					}
				}

				for field, value := range source {
					if _, ok := highlight[field]; !ok {
						valueJSON, _ := json.Marshal(value)
						content.WriteString(fmt.Sprintf("%s: %s\n", field, string(valueJSON)))
					}
				}

				contents = append(contents, mcp.Content{
					Type: "text",
					Text: strings.TrimSpace(content.String()),
				})
			}

			return contents, nil
		})

	// Tool 4: Get shards
	server.AddTool("get_shards", "Get shard information for all or specific indices",
		func(params map[string]interface{}) ([]mcp.Content, error) {
			index, _ := params["index"].(string)

			var res *esapi.Response
			var err error
			if index != "" {
				res, err = es.Cat.Shards(
					es.Cat.Shards.WithIndex(index),
					es.Cat.Shards.WithFormat("json"),
				)
			} else {
				res, err = es.Cat.Shards(
					es.Cat.Shards.WithFormat("json"),
				)
			}
			if err != nil {
				return nil, fmt.Errorf("failed to get shard information: %v", err)
			}
			defer res.Body.Close()

			var shards []map[string]interface{}
			if err := json.NewDecoder(res.Body).Decode(&shards); err != nil {
				return nil, fmt.Errorf("failed to decode response: %v", err)
			}

			content, err := json.MarshalIndent(shards, "", "  ")
			if err != nil {
				return nil, fmt.Errorf("failed to marshal shards info: %v", err)
			}

			return []mcp.Content{
				{Type: "text", Text: fmt.Sprintf("Found %d shards%s", len(shards), func() string {
					if index != "" {
						return fmt.Sprintf(" for index %s", index)
					}
					return ""
				}())},
				{Type: "text", Text: string(content)},
			}, nil
		})

	return server, nil
}

// 辅助函数：将 interface{} 切片转换为 string 切片
func interfaceSliceToStringSlice(slice []interface{}) []string {
	result := make([]string, len(slice))
	for i, v := range slice {
		result[i] = fmt.Sprint(v)
	}
	return result
}

func main() {
	config := &Config{
		URL:      os.Getenv("ES_URL"),
		APIKey:   os.Getenv("ES_API_KEY"),
		Username: os.Getenv("ES_USERNAME"),
		Password: os.Getenv("ES_PASSWORD"),
		CACert:   os.Getenv("ES_CA_CERT"),
	}

	server, err := createElasticsearchMcpServer(config)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating server: %v\n", err)
		os.Exit(1)
	}

	transport := stdio.NewTransport()
	if err := server.Connect(transport); err != nil {
		fmt.Fprintf(os.Stderr, "Error connecting server: %v\n", err)
		os.Exit(1)
	}

	// 处理信号
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
	<-sigChan

	if err := server.Close(); err != nil {
		fmt.Fprintf(os.Stderr, "Error closing server: %v\n", err)
		os.Exit(1)
	}
}
